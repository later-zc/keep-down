# 一. this 的绑定规则



## 1. this 到底指向什么呢？
:::info
`this` 表示**函数运行时的上下文对象**，是 JavaScript 中的一个关键字，在函数运行时自动出现。但它的值并不是固定的，而是根据函数的**调用方式**决定。
:::
**❓先来看一个让人困惑的问题：**
> 下面我们用同一个函数 foo，分别用三种方式调用，观察 this 的指向。
```js
function foo() { 
  console.log(this)
}

// 方式一：直接调用（默认绑定）
foo()

// 方式二：通过对象调用（隐式绑定）
var obj = {
  name: 'later',
  foo: foo
}
obj.foo()

// 方式三：使用 call 显式绑定
foo.call('abc')
```
**🔍 分析运行结果（📍分别说明浏览器和 Node.js）**
| 调用方式 | 代码 | 浏览器中的 this | Node.js 中的 this |
| - | - | - | - |
| 直接调用 | `foo()`	| window(非严）undefined(严）| global（非严）undefined（严）|
| 隐式绑定 |	`obj.foo()` | obj | obj |
| 显式绑定 |	`foo.call('abc')` |	`String {'abc'}`(非严）`'abc'`(严) |	`[String: 'abc']`(非严）`'abc'`(严) |

**🤯 这说明了什么？**
> 1. 函数调用时，JavaScript **为 this 自动绑定一个值**； 
> 2. `this` 的指向**与函数定义的位置无关**； 
> 3. 它完全依赖于函数的**调用方式**和所处的**运行环境**； 
> 4. `this` 是在**运行时**绑定的，而非编译期决定。

  
**那么 this 到底是怎么样的绑定规则呢？**
> 我们可以总结为 4条基础绑定规则+1个特殊情况，按照匹配顺序如下：

| 优先级 | 绑定方式 | 示例 | this 指向 |
|----|------|----|---------|
| 1️⃣ | new 绑定 | `new Foo()` | 新创建的对象（构造器的实例） |
| 2️⃣ | 显式绑定 | `foo.call(obj)` | `call/apply/bind` 显式传入的对象 |
| 3️⃣ | 隐式绑定 | `obj.foo()` | 调用该函数的对象 `obj` |
| 4️⃣ | 默认绑定 | `foo()` | 非严：全局对象（window 和 global)，严：`undefined` | 
| +  | 特殊绑定 | 内置函数 / 箭头函数 / `setTimeout(fn)` | 各有例外（详见后文） |

**📌 小贴士：如何判断 this 到底绑定了什么？**
> 我们可以通过“**调用栈分析法**”+“优先级匹配”来判断：
> 1. 函数是否通过 `new` 调用？ → 优先级最高
> 2. 是否使用了 `call / apply / bind`？ → 显式绑定 
> 3. 是否作为对象属性调用？ → 隐式绑定
> 4. 否则 → 默认绑定
> 5. 特殊语法（箭头函数、定时器等）另行分析

**🔔 关于 this 的误解很多，常见陷阱包括：**
> - 将函数赋值给变量或参数后调用，导致绑定丢失；
> - `setTimeout(fn, 0)` 中 `this` 被重置； 
> - `this` 和作用域、闭包是完全不同的概念； 
> - 箭头函数没有自己的 `this`，它继承外层作用域。



## 2. 规则一：默认绑定
:::info **什么情况下使用默认绑定？**
> 默认绑定的规则适用于**独立函数调用**，即：**函数没有被绑定在某个对象上调用时，this 默认指向全局对象**（或为 undefined，取决于是否开启严格模式）。
> 
> 换句话说，如果一个函数是以最普通的方式直接调用的，例如 foo()，而不是通过对象引用调用（如 obj.foo()），那么默认绑定就生效。
:::
**🔹 案例一：最基础的独立函数调用**
```js
function foo() {
  console.log(this)
}

foo()
```
| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**🔹 案例二：函数嵌套调用中的默认绑定**
```js
function fn1() {
  console.log(this)
}

function fn2() {
  fn1() // 直接调用
}

fn2()
```
> fn1() 作为普通函数直接调用，因此 this 应用默认绑定规则。与是否由另一个函数调用它无关。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**🔹 案例三：函数定义在对象中，但通过变量或参数调用**
```js
var obj = {
  bar: function () { // obj 中的 bar 保存的实际是该函数的引用(内存地址)
    console.log(this)
  }
}

var baz = obj.bar // baz 在内存中指向的是 obj 的 bar 属性所指向的函数的内存地址
baz() // 直接调用（这里调用实际就是通过内存地址找到堆内存中的函数，独立调用该函数）
```
> 尽管函数最初是定义在 obj 中的，但通过变量 baz 调用时，它已经“脱离”了对象上下文。  
> 相当于 baz() 是直接函数调用 → 使用默认绑定规则。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**🔹 案例四：通过参数传递函数引用，触发默认绑定**
```js
var obj = {
  bar: function () {
    console.log(this)
  }
}

function fn1(fn) {
  fn() // 直接调用
}
fn1(obj.bar) // 这里传入的是 obj 的 bar 属性所指向的函数的内存地址(引用)
```
> obj.bar 是一个函数引用（内存地址），传给 fn1 后没有绑定到任何对象上。   
> fn() 是直接调用，仍然触发默认绑定规则。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**📍 默认绑定规则**
| 判断要点 | this 的绑定值 |
|-|-|
| 函数直接调用（非严格模式） |	浏览器：`window`；Node.js：`global` |
| 函数直接调用（严格模式） | `undefined` |
| 函数通过变量引用或参数传递后直接调用 | 默认绑定规则生效 |

**💡记忆小贴士：函数“脱离了对象”，就会落入“默认绑定”的掌控之中。**



## 3. 规则二：隐式绑定
:::info
在 JavaScript 中，`this` 的指向**并不是由函数在哪里定义决定的，而是由它被调用的方式决定的。
当一个函数通过对象属性调用时，this 会被“隐式”绑定到该对象上。**
:::

**🔍 什么是隐式绑定？**  
```js
// 调用形式
object.method()
```
只要函数是通过**对象属性**来访问并调用的，那么在调用过程中，JavaScript 引擎就会将该对象绑定为函数内部的 `this`。

**✅ 示例 1：基础隐式绑定**
```js
function sayName() {
  console.log(this.name)
}

const person = {
  name: 'Alice',
  sayName: sayName
}

person.sayName()
```
> 函数 sayName 被作为 person 对象的属性来调用，所以 this 被绑定为 person 对象。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | 'Alice' | 'Alice' |
| Node.js | 'Alice' | 'Alice' |

**✅ 示例 2：多层对象访问**
```js
function greet() {
  console.log(this.name)
}

const user1 = { name: 'Tom', greet: greet }
const user2 = { name: 'Jerry', user1: user1 }

user2.user1.greet()
```
> 调用语句是 user2.user1.greet()，但真正调用函数的是 user1； 所以 this 绑定为 user1。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-|-|
| 浏览器 | 'Tom' | 'Tom' |
| Node.js | 'Tom' | 'Tom' |

**⚠️示例 3：函数赋值导致隐式绑定丢失️**
```js
function show() {
  console.log(this)
}

const obj = {
  show: show
}

const fn = obj.show
fn() // 输出：？
```
🧠 你可能以为 this 还是 obj，但其实不是！
> fn() 是直接调用，不再通过 obj，所以默认绑定规则会生效。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|--------|--------|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**⚠️示例 4：参数传递时也会发生隐式丢失**
```js
function display() {
  console.log(this)
}

const context = {
  display: display
}

function callFn(fn) {
  fn() // 独立调用
}

callFn(context.display) // 输出：？
```
> 尽管传入的是 context.display，但传入的仅仅是函数引用，传入函数后是“直接调用”，不再有对象上下文了，所以发生了隐式绑定丢失。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|--------|--------|
| 浏览器 | window | undefined |
| Node.js | global | undefined |

**🧠 小结：隐式绑定的要点**
| 调用方式               | this 绑定对象 |
| ------------------ | --------- |
| `obj.fn()`         | obj     |
| `obj1.obj2.fn()`   | obj2    |
| `var fn = obj.fn`  | 默认绑定（隐式绑定丢失）  |
| `callback(obj.fn)` | 默认绑定（隐式绑定丢失）  |


## 4. 规则三：显式绑定
:::info
在隐式绑定中，`this` 的绑定依赖于调用对象。而**显式绑定**允许我们通过 call、apply 和 bind **“手动指定” this 的指向**，不再依赖于调用位置。
:::

**📌 什么是显式绑定？**
> JavaScript 中每一个函数都拥有 `.call()` 和 `.apply()` 方法，它们的**第一个参数就是用于绑定 this 的值**。
```js
func.call(thisArg, arg1, arg2, ...)    // 参数列表
func.apply(thisArg, [arg1, arg2, ...]) // 参数数组
```
> thisArg：函数运行时要绑定为 this 的对象，后续参数分别作为函数调用时传入的参数。

对于这类，明确了 this 要绑定的对象的这种形式，我们称之为**显式绑定**。

**✅ 示例 1：使用 call 显式绑定**
```js
function sayHello() {
  console.log(this.name)
}

const person = { name: 'Later' }

sayHello.call(person)
```
> sayHello 原本是独立函数，通过 .call(person) 显式绑定 this，使其指向 person。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|-------|------|
| 浏览器 | 'Later' | 'Later' |
| Node.js | 'Later' | 'Later' |

**✅ 示例 2：使用 apply 显式绑定 + 传参**
```js
function introduce(language, hobby) {
  console.log(`${this.name} speaks ${language} and likes ${hobby}`)
}

const user = { name: 'Alice' }

introduce.apply(user, ['JavaScript', 'reading']) 
```
> .apply() 与 .call() 区别仅在参数形式，this 显式绑定为 user。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|---|--|
| 浏览器 | 'Alice speaks JavaScript and likes reading' | 'Alice speaks JavaScript and likes reading' |
| Node.js | 'Alice speaks JavaScript and likes reading' | 'Alice speaks JavaScript and likes reading' |

**🧩 示例 3：函数定义不在对象中，但可对任意对象调用**
```js
function showAge() {
  console.log(this.age)
}

const user = { age: 20 }

showAge.call(user)
```
> 不需要函数写在对象中，也能让它“像是”属于对象一样被调用。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|----|----|
| 浏览器 | 20 | 20 |
| Node.js | 20 | 20 |

**✅ 示例 4：bind 返回新函数并绑定 this**
```js
function greet() {
  console.log(this.name)
}

const user = { name: 'Later' }

const boundGreet = greet.bind(user)

boundGreet() // 输出：'Later'
```
> .bind() 不会立即调用函数，它返回一个永久绑定了 this 的新函数。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|----|----|
| 浏览器 | 'Later' | 'Later' |
| Node.js | 'Later' | 'Later' |

**⚠️ 注意事项**
1. **call 和 apply 是立即调用（单次绑定）**； 
2. **bind 是返回函数（永久绑定）**； 
3. **显式绑定优先级高于隐式绑定！**
```js
function say() {
  console.log(this.name)
}

const obj = { name: 'Tom' }
const obj2 = { name: 'Jerry', say: say }

obj2.say.call(obj)
```
> 虽然原本 obj2.say() 是隐式绑定，但 call(obj) 显式绑定后，以 obj 为准。

| 运行环境 | 非严格模式输出 | 严格模式输出 |
|-|----|----|
| 浏览器 | 'Tom' | 'Tom' |
| Node.js | 'Tom' | 'Tom' |

**🧠 小结**
| 方法      | 是否立即调用    | 是否改变 this | 参数形式     |
| ------- | --------- | --------- | -------- |
| call  | ✅ 是       | ✅ 是       | 逗号分隔参数列表 |
| apply | ✅ 是       | ✅ 是       | 参数数组     |
| bind  | ❌ 否（返回函数） | ✅ 是（永久绑定） | 参数列表（可选） |



## 5. 规则四：new 绑定
:::info
在 JavaScript 中，函数不仅仅是可调用的单位，也可以被**当作构造函数使用**。通过 `new` 关键字调用函数时，会触发一套独特的绑定规则 —— **`this` 会绑定到一个新创建的对象上**。
:::

**📌 什么是 new 绑定？** 

当我们使用 new 调用一个函数时，该函数会执行如下 4 个步骤：
> 1. 在堆内存中，创建一个全新的空对象；
> 2. 这个新对象的隐式原型 `__proto__` 被连接到函数的显式原型 `prototype` 属性上； 
> 3. 函数内部的 `this` 被绑定到这个新对象上；
> 4. 执行函数体代码，如果该函数没有显式返回一个**对象类型**（**其他类型无效，会返回隐式创建的新对象**），则隐式返回这个新创建的对象。

使用 new 关键字来调用函数是会执行如下的操作：
```js
function Person(name) {
  console.log(this) // this 指向堆内存中新创建的空对象
  console.log(this == p1) // false 因为这时p1还只是个undefined，在堆内存中新创建出来的对象这时还并没有赋值给p1
  this.name = name
}

var p1  = new Person('later')
console.log(p1) // Person {name: 'later'} 这个时候p1已经拿到创建出来的新对象的引用了
```

**✅ 示例 1：基础构造函数使用**  
```js
function Person(name) {
  console.log(this) // 输出：新创建的对象
  this.name = name
}

const p1 = new Person('Later')
console.log(p1) // 输出：Person { name: 'Later' }
```
> - new Person() 自动将 this 指向一个新的对象；
> - this.name = name 给新对象赋值；
> - 返回新对象赋值给 p1。

**❓ 为何 this == p1 是 false？**
```js
function Person(name) {
  console.log(this == p1) // false，因为此时还未赋值给 p1，等函数体中代码执行完成才会赋值给 p1。
  this.name = name
}
const p1 = new Person('Later')
```
> - this 指向新创建对象； 
> - 但 p1 变量直到构造函数返回后，才会拿到这个对象的引用。

**✅ 示例 2：构造函数显式返回对象时**
```js
function Foo() {
  this.name = 'Later'
  return { name: 'Override' }
}

const obj = new Foo()
console.log(obj) // 输出：{ name: 'Override' }
```
> - 如果构造函数显式返回一个对象，这个对象会覆盖默认返回的 this；
> - 但如果**返回的是非对象类型**（如字符串、数字、布尔值等），则**忽略返回值**：
```js
function Foo() {
  this.name = 'Later'
  return 'hello'
}

console.log(new Foo()) // 输出：Foo { name: 'Later' }
```

**📊 new vs 普通调用对比**
| 场景        | 普通调用          | new 调用             |
| --------- | ------------- | -------------------- |
| this 指向 | 受默认/隐式/显式绑定控制 | 始终指向新创建的对象           |
| 是否创建对象    | ❌ 否           | ✅ 是，自动创建新对象并绑定原型     |
| 返回值处理     | 正常返回          | 显式返回对象类型会替换默认返回；其他类型无效 |



## 6. 特殊规则：内置回调中的 this 是怎么绑定的？
:::info
在实际开发中，除了我们能直接控制调用方式的函数外，还有很多“你不会直接调用，但会传给系统或框架调用”的函数，比如： 
> setTimeout 的回调函数、DOM 元素上的事件处理函数、forEach 等数组方法的回调函数。

这些函数的 this 是由 **JavaScript 引擎或宿主环境决定的**，不遵循我们之前讲过的四大规则，属于特殊绑定场景。
:::

**1️⃣ 问题一：setTimeout 回调函数中的 this 到底是谁？**

❓实际开发中我们常会写出这样的代码：
```js
setTimeout(function () {
  console.log(this)
}, 1000)
```
> - 这个函数不是我们调用的，而是 JS 引擎在 1000ms 后自动调用的；   
> - 我们没有任何“调用方”，也无法指定；
>- 那么 this 到底指向谁？

📋 输出结果对比：
| 运行环境    | 严格模式 this    | 非严格模式 this   |
| ------- | ------------ | ------------ |
| 浏览器 | window | window |
| Node.js | Timeout 对象 | Timeout 对象 |

✅ 原因解析：
> - 在浏览器中，无论是否严格模式，setTimeout 回调函数中的 this 会被隐式绑定到 window；
> - 在 Node.js 中，无论是否严格模式，setTimeout 回调函数由 lib/timers.js 中调度，this 是一个 Timeout 包装对象；

**✅ 实战建议：使用箭头函数解决 this 丢失**
```js
const obj = {
  name: 'Later',
  run() {
    setTimeout(() => {
      console.log(this.name) // 'Later'
    }, 1000)
  }
}

obj.run()
```
> - 箭头函数没有自己的 this，会从定义位置向上寻找；
> - 所以此处的 this 正确绑定到 obj。

📋 输出结果对比：
| 运行环境 | 严格模式 | 非严格模式 |
| ------- | ------------ | ------------ |
| 浏览器 | Later | Later |
| Node.js | Later | Later |

**2️⃣ 问题二：DOM 事件回调中的 this 是谁？**

❓在浏览器网页开发中，你是否写过这样的代码？
```js
btn.onclick = function () {
  console.log(this === btn) // 👉 true
}
```

✅ 原因：
> - 在浏览器中，事件监听器里的 this 会被隐式绑定为触发事件的元素；
> - 宿主环境帮你做了 this 的绑定。

❌ 如果你使用箭头函数：
```js
btn.onclick = () => {
  console.log(this) // 👉 window（或 undefined），不是 btn！
}
```
**📋 事件回调中的 this 对比：**
| 写法       | this 指向      | 可控制性   |
| -------- | ------------ | ------ |
| function | 事件触发的 DOM 元素 | ❌ 自动绑定 |
| 箭头函数     | 外层作用域的 this  | ❌ 无法绑定 |

✅ 实战建议：
> - 需要访问当前元素时，一定使用普通函数； 
> - 如果你不关心 this 或想用箭头函数保持上下文，确保不会用到事件源。

**3️⃣ 问题三：数组 forEach/map 等方法中的回调 this 是谁？**

❓你写过类似代码吗？
```js
const list = ['a', 'b', 'c']
list.forEach(function (item) {
  console.log(this) // 是什么？
})
```
📋 输出结果对比：
| 运行环境 | 非严格模式 | 严格模式 |
| ------- | ------------ | ------------ |
| 浏览器 | window | undefined |
| Node.js | globalThis | undefined |

但你可以这样明确指定：
```js
const context = { name: 'Later' }

list.forEach(function (item) {
  console.log(this.name) // 👉 'Later'
}, context)
```

⚠️ 注意箭头函数不会绑定 this：
```js
list.forEach(item => {
  console.log(this) // 外层作用域的 this，不会是 context
}, { name: 'no effect' })
```

**📋 forEach 回调中的 this 对比：**
| 形式                  | 严格模式 this   | 非严格模式 this                    |
| ------------------- | ----------- | ----------------------------- |
| function，无 thisArg  | `undefined` | `window`（浏览器）或 `global`（Node） |
| function，有 thisArg  | thisArg     | thisArg                       |
| 箭头函数（不管是否传 thisArg） | 外层作用域 this  | 外层作用域 this                    |

**🧠 总结建议：**
| 场景                 | this 绑定行为                    | 推荐使用方式                   |
| ------------------ | ---------------------------- | ------------------------ |
| setTimeout(fn)   | 浏览器：window<br>Node：Timeout对象 | 使用箭头函数继承外部 this          |
| DOM 事件（function）   | this === 事件源元素               | 保留普通函数语法                 |
| DOM 事件（箭头）         | this === 外层作用域               | 不建议用于操作当前元素              |
| forEach(fn, ctx) | ctx 或默认规则                    | 用 function + thisArg 最稳妥 |
| forEach(arrow)   | this 为外层作用域                  | 推荐用于无 this 操作的简洁场景       |



# 二. apply / call / bind（创建绑定 this 的函数）

::: info 🚩开发中遇到的问题
在很多时候，我们并不希望某个函数“属于对象”，但又想临时把它的 this 指向某个对象。  
答案是：使用 JavaScript 为函数提供的 3 个工具方法： call()、apply()、bind()。
:::
例如：
```js
function printInfo() {
  console.log(this.name)
}

const user = { name: 'Later' }

printInfo()         // ❌ this 是 window 或 undefined
user.printInfo = printInfo
user.printInfo()    // ✅ this 是 user
```
> 但我其实并不想写 user.printInfo = printInfo 这样多余的赋值，我只想临时指定 this，就像下面这样直接调用：
```js
printInfo.call(user)
```
> 于是我们就需要 JavaScript 提供的三个工具函数：call / apply / bind —— 它们都是为了解决一个问题： 
> 🧭 “如何在不改变函数定义位置的前提下，控制 this 的绑定？”

**1️⃣ 显式绑定：使用 call() / apply()**

这两个方法都能在调用函数时，显式指定 this。

语法区别：
```js
func.call(thisArg, arg1, arg2, ...)
func.apply(thisArg, [arg1, arg2, ...])
```
> - 第一个参数 thisArg：要绑定的 this 对象；
> - 其他参数：函数的实参（call 用参数列表传入、apply 用数组传入）；
> - 都是立即执行。

**🧪 案例一：call/apply 绑定 this**
```js
function bar() {
  console.log(this)
}

bar.call({ name: 'later' }) // output: { name: 'later' }
bar.call(123)               // output: Number对象，包装123
```
> - bar() 是一个普通函数，默认绑定规则下会指向 window（非严格）；
> - 但通过 call()，我们强制将 this 指向传入的对象；
> - 即使传入的是一个原始值，也会自动被包装成对象（如 123 → new Number(123)）。

**🧪 案例二：传递参数**
```js
function foo(name, age, height) {
  console.log("foo函数被调用:", this)
  console.log("打印参数:", name, age, height)
}

// apply: 参数作为数组传入
foo.apply("apply", ["kobe", 30, 1.98])

// call: 参数以逗号分隔
foo.call("call", "james", 25, 2.05)
```

**🧪 示例三：绑定原始类型或 null/undefined**
```js
function show() {
  console.log(this)
}

show.call(123)        // Number 包装对象
show.call('abc')      // String 包装对象
show.call(null)       // 默认绑定规则生效
show.call(undefined)  // 同上
```

📋 运行环境差异表：
| thisArg | 浏览器 非严格 | 浏览器 严格 | Node 非严格   | Node 严格 |
| ------- | ---------- | ----------- | ---------- | ---------- |
| 123       | `Number {123}` | 123  | `[String: 'abc']` | 123  |
| 'abc'     | `String {'abc'}` | 'abc'  | `[Number: 123]` | 'abc' |
| null      | window   | null      | global   | null      |
| undefined | window   | undefined | global   | undefined |

::: info 如果我们希望一个函数总是显式的绑定到一个对象上，可以怎么做呢？
使用 bind
:::
**2️⃣ bind：不执行函数，只返回一个“永久绑定了 this 的新函数”**

📘 基本语法：
```js
const newFn = fn.bind(thisArg, preset1, preset2, ...)
```
> - 不会调用该函数，而是**返回一个新的绑定了 this 的函数（Bound Function，BF）**;
> - 绑定函数是一个` exotic function object`（**怪异函数对象**，`es6 `中的术语）
> - 可“预设”部分参数（类似柯里化），调用时自动填充。bind 的另一个最简单的用法是使一个函数拥有预设的初始参数：**bind 方法中传入的除 thisArg 之外的其余参数，会作为返回的新函数的初始参数，而新函数调用时传入的参数会排在这些初始（预设）参数之后**。

**🧪 示例：延迟调用 + 预设参数**
```js
function add(a, b, c) {
  console.log(this.name, a, b, c)
}

const obj = { name: 'Later' }

const boundFn = add.bind(obj, 1) // 预设参数
boundFn(2, 3)  // Later 1 2 3
```
> bind(obj, 1)：返回一个新函数，调用它时 this 永远是 obj，且第一个参数始终是 1。

**⚠️ bind 函数的 this 是不可再更改的**
```js
const boundFn = foo.bind({ name: 'A' })
boundFn.call({ name: 'B' }) // 仍然输出 A，不是 B
```
> 一旦 bind 绑定了 this，就无法通过 call/apply 再次修改。

**3️⃣ ⚠️ 箭头函数不支持 call / apply / bind 绑定 this**
> 由于箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个箭头函数时，只能传递参数（不能绑定 this），他们的第一个参数会被忽略。（这种现象对于 bind 方法同样成立）

例如：
```js
var adder = {
  base: 1,
  add: function(a) {
    var f = v => v + this.base
    return f(a)
  },
  addThruCall: function(a) {
    var f = v => v + this.base
    var b = { base: 2 }
    return f.call(b, a) // call 无效
  }
}

console.log(adder.add(1))         // 输出 2
console.log(adder.addThruCall(1)) // 仍然输出 2
```
> f 是一个箭头函数，this 只能从定义时外层作用域捕获，call(b) 无效！

**✅ 总结 & 对比表**
| 方法 | 是否立即调用 | 返回新函数？ | 参数形式      | 是否能绑定 this | 箭头函数生效？ |
| ----- | ------ | ------ | --------- | ---------- | ------- |
| call  | ✅      | ❌      | 参数列表      | ✅          | ❌（无效）   |
| apply | ✅      | ❌      | 参数数组      | ✅          | ❌（无效）   |
| bind  | ❌      | ✅      | 参数预设+调用追加 | ✅（且不可被改）   | ❌（无效）   |

**🎯 实战使用建议**
| 需求场景 | 推荐方法 |
| ---------------- | ------------ |
| 立即执行 + 指定 this          | call 或 apply |
| 延迟执行 + this 永久绑定       | bind  |
| 想修改箭头函数的 this（别想了）  | 不可能 |
| 要兼容数组参数（如 from apply） | apply |



# 三. this 的绑定优先级对比
:::info
学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？
:::

**1️⃣ 默认绑定优先级最低**
> 毫无疑问，默认规则的优先级是最低的，一旦存在其他规则，默认绑定会被完全覆盖。
```js
function foo() {
  console.log(this)
}

foo() // 默认绑定：浏览器中 this -> window
foo.call({ name: 'later' }) // 显式绑定，this -> { name: 'later' }
```

**2️⃣ 显式绑定 > 隐式绑定**
> 当隐式绑定与 call/apply 显式绑定冲突时，显式绑定优先级更高。
```js
var obj = {
  foo: function() {
    console.log(this)
  }
}

obj.foo.call('haha') // output：String {'haha'}
```
:::details 分析
> - 本来调用的是 obj.foo，按隐式绑定应为 obj；
> - 但 call('haha') 明确指定了 this；
> - 所以 this 指向 'haha' 被包装的对象。
:::

**3️⃣ bind > call/apply**
> bind 是“永久绑定”，优先级比 call/apply 更高。
```js
function func() { console.log(this) }

var func2 = func.bind('haha')

func2.call('hehe')   // output：String {'haha'}
func2.apply('hehe')  // output：String {'haha'}
```
:::details
> - bind('haha') 返回了一个新函数；
> - 后续调用 call('hehe') 是作用在这个绑定过的函数上，无法修改 this；
> - 所以最终输出仍然是 'haha'。
:::

**4️⃣ new 绑定优先级最高**
> - new 是唯一可以“完全忽略 bind 的绑定”的规则；
> - 一旦用了 new，即使这个函数是 bind 过的，也会以构造方式优先执行。
```js
function func() {
  console.log(this)
}

var func2 = func.bind('haha')

new func2() // this -> 新创建的对象
```
::: details
> - func2 是绑定了 'haha' 的函数；
> - 但 new 的绑定优先级更高，它会创建一个新对象，并将 this 绑定到新对象；
> - 所以 this 是一个新的实例对象。
:::

:::warning ⚠️ 注意
new 和 call / apply 是不能一起使用的，你不能这样写：`new func.call(obj)`，这是无意义的表达式， 但可以 `new (func.bind(obj))()`，这时 new 优先级仍然最高。
:::

**✅ 总结：绑定优先级从低到高如下**
| 优先级(依次递增) | 绑定方式     | 说明                         |
| --- | -------- | -------------------------- |
| 1   | 默认绑定     | 无调用对象、无 call/apply/new 时生效 |
| 2   | 隐式绑定     | 通过对象调用函数：obj.fn()          |
| 3   | 显式绑定     | call/apply 强制指定 this       |
| 4   | bind 绑定  | bind 返回永久绑定 this 的新函数      |
| 5   | new 构造绑定 | 创建新对象并绑定 this，**优先级最高**    |



# 四. 绑定之外的情况

---

## 1. this规则之外 – 忽略显示绑定

- 我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外（神话故事和动漫中总是有类似这样的人物）

- 情况一：如果在**显示绑定中**，我们**传入一个`null`或者`undefined`**，那么这个**显示绑定会被忽略**，**使用默认规则**：

  - 严格模式下，显示绑定`null`或`undefined`，`this`指向的是原生基本数据类型
  - 非严格模式下，显示绑定`null`或`undfined`，`this`指向`window`
    - **因为`null`和`undefined`没有对应的包装类型**

  ```js
  function foo() { console.log(this) }
  var obj  = {
    name: 'why'
  }
  
  foo.call(obj) // output：obj对象 => obj对象(严格模式下)
  foo.call('abc') // output：String {'abc'} => 'abc'(严格模式下)
  foo.call(null) // output：window => null(严格模式下)
  foo.apply(undefined) // output：window =>  undefined(严格模式下)
  
  var bar = foo.bind(null)
  bar() // output：window => null(严格模式下)
  ```

## 2. this规则之外 - 间接函数引用

- 情况二：创建一函数的间接引用，这种情况使用默认绑定规则

  - 赋值`(obj2.foo = obj1.foo)`的结果是`foo`函数
  - `foo`函数被直接调用，那么是默认绑定

  ```js
  function foo() { console.log(this) }
  var obj1  = {
    name: 'obj1',
    foo: foo
  }
  
  var obj2 = {
    name: 'obj2'
  }
  
  obj1.foo(); // obj1对象
  (obj2.foo = obj1.foo)() // window 
  // 圆括号会当成一个表达式去解析，而该表达式内部在赋值的同时，也会返回表达式右侧的值(即obj1中的foo属性所指向的函数)，所以这里是会当成一个独立的函数调用
  ```

## 3. this规则之外 – ES6箭头函数的this使用

- 箭头函数不使用`this`的四种标准规则（也就是**不绑定`this`**），而是**根据外层作用域来决定`this`**

- 我们来看一个模拟网络请求的案例：

  - 这里使用`setTimeout`来模拟网络请求，请求到数据后如何可以存放到`data`中呢？
  - 我们需要拿到`obj`对象，设置`data`
  - 但是直接拿到的`this`是`window`，我们需要在外层定义：`var _this = this`
  - 在`setTimeout`的回调函数中使用`_this`就代表了`obj`对象

  ```js
  var obj = {
    data: [],
    getData: function() {
      var _this = this; // 当通过obj.getData调用函数时，函数内部的this绑定到了obj对象，定义一个函数内部的变量_this指向函数内部的this，当执行setTimeout中的回调函数时，其中的this是执行window的，因为setTimeout中的函数是显示绑定到window身上的，所以其内部的回调函数中this执行的就是window了，当我们使用_this变量，会往上层作用域一层一层往查找该变量，最后在上层函数作用域中找到_this变量
      setTimeout(function() {
        // 模拟获取到的数据
        var res = ['abc', 'cba']
        _this.data.push(...res)
      }, 1000)
    }
  }
  
  obj.getData()
  ```





# 五. 箭头函数的使用

---

## 1. 箭头函数 arrow function

- 箭头函数是`ES6`之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：

  - **箭头函数不会绑定`this`、`arguments`属性，即使使用 `call` 等显示绑定也无用，只能从上层作用域中查找**
  - 箭头函数**不能作为构造函数来使用**（不能和`new`一起来使用，会抛出错误）
    - 所以**箭头函数是没有显式原型的，但是作为对象是有隐式原型**

- 箭头函数如何编写呢？

  - ()：函数的参数
  - {}：函数的执行体

  ```js
  // 1.之前的方式
  function foo1() {}
  var foo2 = function(name, age) {
    console.log("函数体代码", this, arguments)
    console.log(name, age)
  }
  
  // 2.箭头函数完整写法
  var foo3 = (name, age) => {
    console.log("箭头函数的函数体")
    console.log(name, age)
  }
  
  // 3.箭头函数的练习
  // 3.1. forEach
  var names = ["abc", "cba", "nba"]
  names.forEach((item, index, arr) => {
    console.log(item, index, arr)
  })
  // 3.2. setTimeout
  setTimeout(() => {
    console.log("----")
  }, 3000)
  ```

## 2. 箭头函数的编写优化

- 优化一：如果**只有一个参数可以省略()**

  ```js
  nums.forEach(item => {})
  ```

- 优化二：如果**函数执行体中只有一行代码(除`return`)，可以省略大括号**，且**会自动返回该行代码的返回值**

  - 如果函数体中只有一行代码，有`return`的时候，不能省略大括号，可以直接去掉`return`，因为这行代码的返回值会作为整个函数的返回值

  ```js
  nums.forEach(item => console.log(item))
  nums.filter(item => item % 2 == 0)
  ```

- 优化三：如果函数执行体**返回值是一个对象**，那么**需要给这个对象加上`()`**

  - 因为如果不加的话，`js`引擎会解析成函数`{}`的执行体

  ```js
  var foo = () => {
    return {name: 'abc'}
  }
  var bar = () => ({name: 'abc'})
  ```





# 六. 箭头函数this的查找规则

---

- 之前的代码在`ES6`之前是我们最常用的方式，从`ES6`开始，我们会使用箭头函数：

  - 为什么在`setTimeout`的回调函数中可以直接使用`this`呢？
  - 因为**箭头函数不绑定`this`对象**，那么`this`引用就会**从上层作用域中找到对应的`this`**
    - 所以`this`绑定对箭头函数是无效的
  - **箭头函数中是没有`this`的，其中`this`是往上层作用域一层一层查找，如果都没有，就是`window`**
  
  ```js
  var obj = {
    data: [],
    getData: function() {
      setTimeout(() => {
        var res = ['abc', 'cba']
        console.log(this) 
        this.data.push(...res)
      }, 1000)
    }
  }
  obj.getData() // output：obj对象
  
  var obj2 = {
    getData: () => {
      setTimeout(() => {
        console.log(this)
      }, 1000)
    }
  }
  obj2.getData() // output：window 因为箭头函数中是没有this的，是往上层作用域一层一层查找的，最外层this指向window对象
  ```
  

> 注意：
>
> - 函数的作用域链是在函数声明（编写/定义）的时候就确定下来了





# 七. this面试题分析

---

```js
var name = '222'
var person = {
  name: 'person',
  sayName: function() {
    console.log(this.name)
  }
}

function sayName() {
  var sss = person.sayName;
  sss()
  person.sayName()
  (person.sayName)()
  (b = person.sayName)()
}

sayName()
// output：
// '222' 默认绑定（独立函数调用）
// 'person' 隐式绑定
// person' 隐式绑定，等同于person.sayName(), 加小括号不加效果完全一样，加小括号控制代码优先级，不加小括号，本身点.语法优先级就很高
// '222' 间接函数引用，赋值语句返回结果即独立函数调用
```

```js
var name = '222'
var person1 = {
  name: 'person1',
  foo1: function() {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function() {
    return function() {
      console.log(this.name)
    }
  },
  foo4: function() {
    return () => {
      console.log(this.name)
    }
  }
}

var person2 = {name: 'person2'}

person1.foo1() // 'person1' 隐式绑定
person1.foo1.call(person2) // 'person2' 显式绑定

person1.foo2() // '222' 上层作用域查找this
person1.foo2.call(person2) // '222' 箭头函数不绑定this，上层作用域查找this

person1.foo3()() // '222' 默认绑定 拿到返回的普通函数直接进行默认调用
person1.foo3.call(person2)() // '222' 默认绑定 拿到返回的普通函数直接进行默认调用
person1.foo3().call(person2) // 'person2' 显式绑定

person1.foo4()() // 'person1' 箭头函数调用会从上层作用域查找this
person1.foo4.call(person2)() // 'person2' 箭头函数调用会从上层作用域查找this
person1.foo4().call(person2) // 'person1' 箭头函数不绑定this，从上层作用域查找this
```

```js
var name = '222'
function Person(name) {
  this.name = name
  this.foo1 = function() {
    console.log(this.name)
  }
  this.foo2 = () => console.log(this.name)
  this.foo3 = function() {
    return function() {
      console.log(this.name)
    }
  }
  this.foo4 = function() {
    return () => {
      console.log(this.name)
    }
  }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // 'person1' 隐式绑定
person1.foo1.call(person2) // 'person2' 显式绑定

person1.foo2() // 'person1' 上层作用域查找：上层作用域中的this绑定到了person1
person1.foo2.call(person2) // 'person1' 不绑定this，上层作用域查找

person1.foo3()() // '222' 默认绑定 独立函数调用
person1.foo3.call(person2)() // '222' 默认绑定 独立函数调用
person1.foo3().call(person2) // 'person2' 显式绑定

person1.foo4()() // 'person1' 上层作用域查找
person1.foo4.call(person2)() // 'person2' foo4函数中this绑定person2，箭头函数查找上层作用域foo4函数中的this
person1.foo4().call(person2) // 'person1' 箭头函数不绑定this，上层作用域查找
```

```js
var name = '222'
function Person(name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function() {
      return function() {
        console.log(this.name)
      }
    },
    foo2: function() {
      return () => {
        console.log(this.name)
      }
    }
  }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // '222' 普通函数默认调用（独立函数调用）
person1.obj.foo1.call(person2)() // '222' 普通函数默认调用（独立函数调用）
person1.obj.foo1().call(person2) // 'person2' 普通函数显式绑定调用

person1.obj.foo2()() // 'obj' 上层作用域中查找到foo2函数作用域中的this隐式绑定obj
person1.obj.foo2.call(person2)() // 'person2' 上层作用域中查找到foo2函数作用域中的this显式绑定person2
person1.obj.foo2().call(person2) // 'obj' 箭头函数不绑定this，上层作用域中查找到foo2函数作用域中的this隐式绑定obj
```

> 总结：
>
> - **普通函数中的`this`，是根据调用的时候绑定的**
> - **箭头函数中是没有`this`的，所以是不被绑定的，会去上层作用域中查找`this`，是根据执行上下文决定的**





# 八. 手写apply、call、bind

---

```js
Function.prototype.executionFn = function(thisArg, args) {
  thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg) // 这里是防止传入绑定的参数为空或者是原始类型的值，如string或number
  Object.defineProperty(thisArg, '_this', {
    configurable: true,
    enumerable: false，
    value: this
  })
  args ? thisArg._this(...args) : thisArg._this()
  delete this._this
}

/**
* 私有的apply方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数数组
*/
Function.prototype._apply = function(thisArg, args) {
  // thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
  // thisArg._this = this
  // Object.defineProperty(thisArg, '_this', {
  //   configurable: true,
  //   enumerable: false
  // })
  // args ? thisArg._this(...args) : thisArg._this()
  this.executionFn(thisArg, args)
}

function foo(name, age) {
  console.log(this, name, age)
}

foo._apply({name: 'later'}, ['later', 18])
foo._apply('abc', ['later', 18])
foo._apply()

/**
* 私有的call方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数列表
*/
Function.prototype._call = function(thisArg, ...args) {
  // thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
  // thisArg._this = this
  // Object.defineProperty(thisArg, '_this', {
  //   configurable: true,
  //   enumerable: false
  // })
  // args ? thisArg._this(...args) : thisArg._this()
  this.executionFn(thisArg, args)
}

foo._call()
foo._call({name: 'later'}, 'later', 18)
foo._call('abc', 'later', 18)
```

```js
function foo(name, age) {
  console.log(this, name, age)
}
/**
* 私有的bind方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数列表
*/
Function.prototype._bind = function(thisArg, ...args) {
  thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
  Object.defineProperty(thisArg, '_this', {
    configurable: true,
    enumerable: false,
    value: this
  })

  return (...rest) => {
    args ? thisArg._this(...args, ...rest) : thisArg._this(...rest)
  }
}

var foo2 = foo._bind({name: 'later'}, 'later')
foo2(23)
foo2(18)
foo2()
var foo3 = foo._bind()
foo3()
```







