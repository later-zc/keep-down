# 一. TypeScript 中类的使用
> 在早期的 JavaScript（ES5）开发中，需要通过函数和原型链来实现类和继承，从 ES6 开始，引入了 class 关键字，可以更加方便的定义和使用类。   
> 在现代 JavaScript（JS）和 TypeScript（TS）中，类是面向对象编程（OOP）的核心概念。
> TS 作为 JS 的超集，可以对类的属性和方法等进行静态类型检测，为我们带来了更强大的类型检查能力。  
> 即使在一些更偏函数式编程的框架（如 React 的函数组件和 Vue3 的 Composition API）中，我们在封装复杂的业务逻辑时依然会频繁使用类来实现模块化、继承和多态。

## 类的定义
在 TypeScript 中，我们使用 class 关键字来定义类，在类的内部声明类的属性以及对应的类型。
::: warning
> - 如果类属性类型没有显式声明或属性没有初始化值，则类型默认 any。  
> - 在 tsconfig.json 配置文件中的 strictPropertyInitialization 开启的情况下，类属性**默认是必须初始化的**，如果**类属性没有初始化值且未在构造函数中明确赋值，那么编译时就会报错。**
> - 如果 strictPropertyInitialization 选项为 true，但确实不希望给类属性初始化，可以使用明确赋值断言：`property!: type` 语法，即在类属性后面加上 `!`，来绕过初始化检查。
:::
示例：
 ```typescript
 class Person {
   name: string;     // [!code error] // Error：属性“name”没有初始化表达式，且未在构造函数中明确赋值
   name2: any;       // 或改为 any 类型
   name3: number;    // 或改为在构造函数中有明确赋值
   name4!: boolean;  // 或改为使用明确赋值断言，跳过初始化检查（带有明确赋值断言的声明还必须具有类型注释）
   name5 = 1;        // 或改为初始化赋值，可省略类型注解，会根据初始值自动推导出类型 
   constructor(name: string, name3: number) {
     this.name3 = name3
   }
 }
  
const p1 = new Person('later', 18)
```

## 类的继承
> 面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。
在 TS 中可以使用 extends 关键字实现类的继承。子类继承父类的属性和方法，还可以有自己的属性和方法。通过 super 关键字，子类可以调用父类的构造函数和方法。

示例：定义一个 Student 类继承 Person 类
```typescript
class Person {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  greet() {
    console.log(`Hello, I am ${this.name}.`)
  }
}

class Student extends Person {
  studentId: number
  constructor(name: string, age: number, studentId: number) {
    super(name, age) // 调用父类的构造函数（必须写在构造函数体的第一行）
    this.studentId = studentId
  }
  sayHello() {
    super.greet()
  }
  study() {
    console.log(`${this.name} is studying.`)
  }
}

const student = new Student("Bob", 20, 12345)
student.sayHello() // 输出: Hello, I am Bob.
student.study()    // 输出: Bob is studying.
```
示例说明：
  > ① Student 类通过 extends 关键字继承了 Person 类。  
  > ② 在 Student 的构造函数中，super 关键字调用了 Person 的构造函数，完成父类属性的初始化。  
  > ③ eStudent 拥有自己特有的 study 方法。


## 类的成员修饰符
TypeScript 提供了 **public、private 和 protected 三种修饰符来控制类成员的可见性**：
::: tip
类成员指的是类中定义的属性，方法等，readonly 修饰符只能用于类属性，不能用于类方法，因此在本节内容不适用。
:::
  | 修饰符 | 含义 | 作用范围 |
  | - | - | - |
  | public（默认） | 公有 | 无限制 |
  | private | 私有 | 只能被类自身访问 |
  | protected | 受保护 | 只能被类自身及子类自身访问 |

示例：
  ```typescript
  // 示例一：protected 修饰的类成员，只能被类自身及子类自身访问
  class Person {
    protected name: string
    constructor(name: string) {
      this.name = name
    }
  }
  
  class Student extends Person {
    constructor(name: string) {
      super(name)
    }
    running() { 
      console.log(this.name) // protected 修饰的类成员，可以被子类自身访问
    }
  }
  
  const p1 = new Person('later')
  const s1 = new Student('later-zc')
  p1.name      // [!code error] // Error：属性“name”是受保护的，只能在类“Person”及其子类中访问
  s1.name      // [!code error] // Error：属性“name”是受保护的，只能在类“Person”及其子类中访问
  s1.running() // 输出: later-zc
  Person.name  // 输出: later-zc
  Student.name // 输出: later-zc


  // 示例二：private 修饰的类成员，只能被类自身访问
  class Person {
    private name: string
    constructor(name: string) {
      this.name = name
    }
  }
  
  const p2 = new Person('later')
  Person.name // 输出: later
  p2.name     // [!code error] // Error：属性“name”为私有属性，只能在类“Person”中访问
  ```


## readonly 修饰类属性为只读
::: warning
readonly 修饰符**只能出现在属性声明或索引签名上，不能用于类方法**。

readonly 是 TypeScript 关键字，它不会在 JavaScript 中生效，**只会在 TS 编译时限制对属性的修改**。
:::
使用 readonly 修饰符的属性只能在初始化或构造函数中赋值，赋值后不可修改。
  ```typescript
  class Person {
    readonly name: string
    constructor(name: string) {
      this.name = name
    }
    updateName(_name: string) {
      this.name = _name // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
    }
  }
  
  const p1 = new Person('later')
  console.log(p1.name)   // 可以访问
  p1.name = 'later-zc';  // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
  p1.updateName('coder') // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
  ```
如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用。 那么可以使用 readonly。


## getters / setters
在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取 `getter` 和设置 `setter` 的过程，这个时候我们可以使用**存取器**。
  ```typescript
  class Person {
    private _name: string
    constructor(name: string) {
      this._name = name
    }
    get name() {
      return this._name
    }
    set name(value: string) {
      this._name = value
    }
  }
  
  const p1 = new Person('later')
  p1.name = 'later-zc' // 设置 name 属性
  console.log(p1.name) // 输出：later-zc
  ```
在这个示例中，我们通过 get 和 set 关键字控制对 _name 属性的访问，这样可以对赋值过程进行校验或修改。


## 参数属性（Parameter Properties）
参数属性是 TS 提供的一种简写方式，可以**在构造函数参数前直接添加修饰符**（如 public、private、protected 或 readonly）**将该构造函数参数转成一个同名同值的类属性**（同时这些类属性也会获得相应的修饰符）。
  ```typescript
  class Person {
    constructor(public name: string, private _age: number) {}
    set age(value: number) {
      this._age = value
    }
    get age() {
      return this._age
    }
  }
  
  const p1 = new Person('later', 18)
  console.log(p1.name) // 'later'
  console.log(p1._age) // [!code error] // Error： 属性‘_age’是私有的，只能在类‘Person’中访问。
  console.log(p1.age)  // 18
  ```
::: warning
> - 参数属性的访问修饰符 `publice` 不能省略，否则会报错。
> - 类成员的访问修饰符 `public` 可以省略，因为其默认就是 `public`。
:::



# 二. TypeScript 中的抽象类

## 什么是抽象类和抽象方法？
> 我们知道，继承是多态使用的前提，抽象类和抽象方法则是实现多态的有效方式。所以在定义很多通用的调用接口时，我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式，
但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法，我们可以定义为抽象方法。

**抽象方法**
> 指的是**用 abstract 关键字声明的方法。不能有方法体，只能存在于抽象类中，且必须在子类中被实现（除非子类也是抽象类）**。

**抽象类**
> 指的是**用 abstract 关键字声明的类，不能被实例化，只能被继承，抽象类可以包含抽象方法，也可以包含有实现体的方法**。
> 通常用来定义一组共有的属性和方法接口，具体的实现交由子类完成。

**为什么要使用抽象类？**
> - **实现多态**：可以在父类中定义通用接口（方法或属性），在子类中实现特定的功能。
> - **限制类的实例化**：抽象类只能作为基类存在，不能直接被实例化，避免了父类实例化带来的不必要问题。

例子：
```typescript
// 定义一个抽象类 Shape（图形类）
abstract class Shape {
  // 声明抽象方法 getArea，无方法体，非抽象类的子类必须实现它
  abstract getArea(): number
  // 非抽象方法：可以在抽象类中定义带有具体实现的方法
  showArea() {
    console.log("图形的面积是: " + this.getArea())
  }
}

// 定义具体的子类 Rectangle（矩形），继承 Shape
class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super()
  }
  // 非抽象类的子类必须实现父类的抽象方法 getArea
  getArea() {
    return this.width * this.height
  }
}

// 定义另一个子类 Circle（圆形），继承 Shape
class Circle extends Shape {
  constructor(public radius: number) {
    super()
  }
  getArea(): number {
    return Math.pow(this.radius, 2) * Math.PI
  }
}

function printArea(shape: Shape) {
  return shape.showArea() 
}

printArea(new Rectangle(10, 20)) // 输出：图形的面积是: 200
printArea(new Circle(5))         // 输出：图形的面积是: 78.53981633974483
printArea(new Shape())           // [!code error] // Error：不能创建抽象类的实例
```
  

## 鸭子类型
> TypeScript 使用鸭子类型（Duck Typing）来进行类型检测，即**只检查对象的结构是否匹配，而不关心对象的实际类型**。也就是说，**只要对象具有对应的属性和方法，它就可以被视为符合某个类型**。

示例：
```typescript
class Person {
  constructor(public name: string, public age: number) {}
  run() {}
}

class Coder {
  constructor(public name: string, public age: number) {}
  run() {}
}

function printPerson(p: Person) {
  console.log(p.name, p.age)
}

// 下面三种情况都不会报错，就是因为 TypeScript 使用的鸭子类型来进行类型检测
// 鸭子类型: 如果一只鸟, 走起来像鸭子, 游起来像鸭子, 看起来像鸭子, 那么你可以认为它就是一只鸭子
// 鸭子类型, 只关心属性和行为, 不关心你具体是不是对应的类型
printPerson(new Coder('later', 20))
const p: Person = new Coder('later', 20)
printPerson({name: 'later', age: 20, run(){}}) // 甚至可以直接传递一个拥有相同属性的对象字面量

class Dog {}
const d: Dog = {} // 这也是符合鸭子类型的
```
在这个例子中，尽管 coder 类不是 Person 类的实例，但它的结构满足 Person 的要求，因此它可以被当作 Person 类型使用。这就是鸭子类型的思想。
不要求对象一定是由对应的类创建的实例，只要结构匹配即可。


## 类作为一种数据类型
在 TypeScript 中，类不仅可以用来创建实例，也可以作为数据类型。一个类的类型描述了该类的实例的结构，包括属性和方法。
  ```typescript
  class Person {}
  
  /**
    * 类的作用:
    *  1. 可以创建类对应的实例对象
    *  2. 类本身可以作为这个实例的类型
    *  3. 类也可以当作有一个构造签名的函数，因为类可以被 new
  */
  
  const p: Person = new Person() // 1
  function printPerson(p: Person) {}
  printPerson(p) // 2
  
  function factory(ctor: new () => void) {}
  factory(Person) // 3
  ```



# 三. TypeScript 对象类型
> 在 TypeScript 中，定义对象类型时，我们可以使用各种修饰符和类型特性来控制属性的可选性、只读性、索引特性等。这样不仅可以定义对象的基本结构，还能限制和规范对象的使用。

## 对象类型的属性修饰符（Property Modifiers）
对象类型中的每个属性可以说明它的类型、属性是否可选、属性是否只读等信息。

### 可选属性（Optional Properties）
> 在 TypeScript 中，我们可以通过**在属性名后加一个 ? 来标记该属性为可选**。这样可以定义对象类型时允许某些属性不出现。

  示例：
  ```typescript
  interface IPerson {
    name: string
    age?: number // 可选属性
  }
  
  const p1: IPerson = { name: "Alice" }        // 没有 age 属性
  const p2: IPerson = { name: "Bob", age: 30 } // 包含 age 属性
  ```

### 只读属性（Readonly Properties）
> 有时候我们希望对象中的某些属性在赋值后不可修改，这时可以在属性前加 readonly 关键字，将该属性设置为只读。这只会在编译时有效，防止该属性被意外修改。
  
  示例：
  ```typescript
  interface ICar {
    readonly brand: string
    model: string
  }
  
  const c1: ICar = { brand: "Toyota", model: "Corolla" }
  c1.model = "Camry"; // 可以修改 model
  c1.brand = "Honda"; // [!code error] // Error：因为 brand 是只读属性
  ```

## 索引签名（Index Signatures）
索引签名用于描述对象中某类动态键的类型，例如数组、字典类型对象等。**索引签名可以使用字符串或数字作为索引，通过索引签名可以灵活定义对象的属性而不必预定义具体的键名**。
::: tip
带有索引签名的接口也可以包含特定名称的属性，但这些属性类型必须兼容索引签名的返回类型。
:::

### 字符串索引签名
当对象的属性名为字符串类型时，可以使用 `[index: string]` 来定义字符串索引签名。比如描述一个字典对象的结构，属性名为字符串，值为指定类型。
```typescript
interface IDictionary {
  // 键名是字符串，值是字符串
  [key: string]: string 
}

const myDictionary: IDictionary = {
  firstName: "Alice",
  lastName: "Smith",
}
```
### 数字索引签名
当属性名为数字类型时，可以使用 `[index: number]` 定义数字索引签名。常见的应用场景是定义数组类型。


  ```typescript
  interface ICollection {
    // 返回值类型的目的是告知通过索引去获取到的值是什么类型
    [index: number]: string
    length: number 
  }
  
  function printCollection(collection: ICollection) {
    for (let i = 0; i < collection.length; i++) {
      const item = collection[i]
      console.log(item.length)
    }
  }
  
  const array = ["abc", "cba", "nba"]
  const tuple: [string, string] = ["why", "广州"]
  printCollection(array)
  printCollection(tuple)
  ```

## 索引签名的严格类型检查
当我们定义的类型有数组特性时，TypeScript 也会对其进行严格检查。通过字面量方式创建的数组，会自动关联数组类型的其他方法属性，例如 forEach、map、filter 等。这些属性的值类型不一定符合索引签名定义的类型。

**示例 1：字面量数组的严格检查**
```typescript
interface IStringIndex {
  [index: string]: string;
}

const myArray: IStringIndex = ["apple", "banana"] // [!code error] // Error： 类型‘string[]’不能赋值给类型‘IStringIndex’。类型‘string[]’中缺少类型‘string’的索引签名。
```
> 为什么会出现上面的情况？
> 因为我们字面量形式定义的数组，是会经过严格字面量赋值检测的，除了会检测 ['abc', 'cba', 'nba'] 中的 ['0']、['1']、['2'] 这几个字符串索引之外，
> 因为数组有 `forEach`、`filter` 等方法，这些属性类型与 string 不匹配，还会检测到['forEach']、['filter']这些字符串索引，而这些索引对应的值就并不符合 string 类型，所以就会报错。
> ```typescript
> // ["abc", "cba", "nba"] => Array实例 => names[0]、names.forEach、...
> // names["forEach"] => function
> // names["map/filter"] => function
> ```
> 既然有严格字面量检查，那我们让它不是新鲜的不就可以绕过检查了吗？ 
> 经过测试发现，可能索引签名这里是比较特殊的，即使使其失去新鲜，仍然会保持严格的字面量检查。

**示例 2：解决方式**  
> 可以通过定义 any 类型索引签名或使用非字面量形式创建数组来解决这个问题。
```typescript
interface IStringIndex {
  [index: string]: any
}

const myArray: IStringIndex = ["apple", "banana"] // 不报错
```

> 当索引类型为 number 时，只会检测 ['abc', 'cba', 'nba'] 中的 [0]、[1]、[2] 这几个数字索引，这几个索引所对应的值也是符合 string 类型的，所以不会报错。
```typescript
interface IStringIndex {
  [index: number]: string
}

const myArray: IStringIndex = ["apple", "banana"] // 不报错
```

## 数字和字符串索引签名的混用

TypeScript 的一个限制是：**当对象同时包含字符串和数字索引签名时，数字索引的值类型必须是字符串索引值类型的子类型**。
> 这是因为在 JavaScript 中，当索引一个数字时，JS引擎 实际上会在索引对象之前将其隐式转换为字符串，obj[0] 等同于 obj["0"]。

错误示例：
  ```typescript
  interface IInvalidIndexType  {
    [index: number]: string | number; // [!code error] // Error：“number”索引类型“string | number”不能分配给“string”索引类型“string”
    [key: string]: string;
  }
  ```
正确示例：  
  > 为了避免报错，可以将字符串索引返回类型改为 any 或者包含数字索引返回类型。
  ```typescript
  interface IValidIndexType {
    [index: number]: string | number
    [key: string]: any // [!code highlight]
  }
  
  const example: IValidIndexType = {
    0: "apple",
    1: "banana",
    fruit: "cherry",
    count: 3,
  }
  ```
::: tip
> - 索引签名的属性类型必须是 `string` 或者是 `number`。
> - 如果索引签名中有定义其他属性，**其他属性返回的类型，也必须符合`string`类型返回的属性**。
:::


## 综合示例：属性修饰符与索引签名的结合
假设我们要定义一个接口 IUserInfo，其中包含用户信息，支持任意扩展字段（例如用户的偏好设置等）。可以结合使用可选属性、只读属性和索引签名。
```typescript
interface IUserInfo {
  readonly id: number
  name: string
  age?: number
  [key: string]: any // 任意扩展字段
}

const user: IUserInfo = {
  id: 101,
  name: 'later',
  age: 25,
  address: 'Shen Zhen',
  isAdmin: true
}
// 不允许修改只读属性 id
user.id = 102; // [!code error] // 报错
```



# 四. TypeScript 接口补充

## 接口继承
在 TypeScript 中，接口（interface）和类（class）一样，可以通过 extends 关键字实现继承。这种继承机制不仅能避免重复代码，还能让接口更易于扩展，尤其是**支持多继承功能（类不支持多继承）**。
  ```typescript
  interface IPerson {
    name: string
    age: number
  }
  
  interface IRun {
    running: () => void
  }
  
  const ikun: IKun = {  // [!code error] // Error：类型“{ slogan: string; }”缺少类型“IKun”中的以下属性: name, age, running
    slogan: '你干嘛，哎哟'
  }
  ```
> 在这个示例中，接口 IKun 继承了 IPerson 和 IRun 的属性和方法，实现了多继承功能。接口继承后，可以把常用的属性集中在父接口中，而具体实现类或接口可以复用这些定义。  

**好处**： 
> - **减少重复代码**：不同接口继承同一个基础接口可以复用属性。 
> - **代码一致性**：尤其在使用第三方库时，通过继承接口可确保新接口也符合库中接口的标准。 
> - **继承后属性检查**：在实现继承接口的对象时，TypeScript 会严格检查所有必需属性。若缺少属性，编译会报错，确保类型安全。


## 接口的实现
接口不仅可以继承，还可以被类实现（implements），使类符合接口的定义，方便统一处理接口和类之间的关系。这种方式也称为面向接口编程，即在代码中通过接口来定义结构、行为，而不是直接依赖具体类。
  
  ```typescript
  interface IKun {
    name: string
    slogan: string
    dance: () => void
  }
  
  interface IRun {
    running: () => void
  }
  
  const ikun: IKun = {
    name: 'later',
    slogan: '你干嘛',
    dance: function() {}
  }
  
  
  class Person implements IKun, IRun {
    constructor(
      public name: string, 
      public slogan: string, 
      public dance: () => void, 
      public running: () => void
    ) {}
  }
  
  const ikun1 = new Person('later', '小黑子', function(){}, function(){})
  console.log(ikun1.name, ikun1.slogan, ikun1.dance, ikun1.running)
  ```
> 在这个例子中，Person 类实现了 IKun 和 IRun 接口，确保类中定义了 IKun 和 IRun 所需的所有属性和方法。这样可以统一接口的定义和具体类的实现逻辑。  

**面向接口编程的好处**： 
> - **灵活性**：可以根据接口定义替换不同实现，代码更灵活。 
> - **模块化**：接口定义清晰，使得不同模块之间依赖关系更清晰。
  

## 3. 抽象类和接口的区别（了解）

- 抽象类在很大程度上和接口会有点类似：都可以在其中定义一个方法，让子类或实现类来实现对应的方法
- 那么抽象类和接口有什么区别呢？
  - 抽象类是事物的抽象，抽象类用来捕捉子类的通用特性，接口通常是一些行为的描述
  - 抽象类通常用于一系列关系紧密的类之间，接口只是用来描述一个类应该具有什么行为
  - 接口可以被多层实现，而抽象类只能单一继承
  - 抽象类中可以有实现体，接口中只能有对象的声明
- 通常我们会这样来描述类和抽象类、接口之间的关系：
  - **抽象类是对事物的抽象**，表达的是` is a `的关系。猫是一种动物（动物就可以定义成一个抽象类）
  - **接口是对行为的抽象**，表达的是` has a `的关系。猫拥有跑（可以定义一个单独的接口）、爬树（可以定义一个单独的接口）的行为





# 五. 特殊: 严格字面量检测

---

## 01. 严格的字面量赋值检测

- 对于对象的字面量赋值，在 `TS` 中有一个非常有意思的现象：

  ```typescript
  // 1.奇怪的现象一: 
  const info: IPerson = {
    name: "why",
    age: 18,
    // 多了一个height属性
    // 报错：不能将类型“{ name: string; age: number; height: number; }”分配给类型“IPerson”。对象文字可以只指定已知属性，并且“height”不在类型“IPerson”中
    height: 1.88 
  }
  
  const obj = {
    name: "why",
    age: 18,
    // 多了一个height属性
    height: 1.88
  }
  
  // 不报错
  const info2: IPerson = obj
  
  
  // 2.奇怪的现象二:
  function printPerson(person: IPerson) {}
  
  printPerson({ name: "kobe", age: 30, height: 1.98 }) // 报错：类型“{ name: string; age: number; height: number; }”的参数不能赋给类型“IPerson”的参数。对象文字可以只指定已知属性，并且“height”不在类型“IPerson”中
  
  const kobe = { name: "kobe", age: 30, height: 1.98 } 
  printPerson(kobe) // 不报错
  ```

## 02. 为什么会出现这种情况呢？

- 这里引入 `TS` 成员在 `GitHub` 的 `issue` 中的回答：

  <img src="./assets/image-20221017200449928.png" alt="image-20221017200449928" style="zoom: 67%;" />

- 简单对上面的英文进行翻译解释：

  - 每个对象字面量最初都被认为是“新鲜的（`fresh`）”
  - 当一个新的对象字面量分配给一个变量或传递给一个非空目标类型的参数时，对象字面量指定目标类型中不存在的属性是错误的
  - 当类型断言或对象字面量的类型扩大时（别的场景扩大使用时），新鲜度会消失
  
  > 总结：
  >
  > - **第一次创建的对象字面量，是新鲜的，会被严格检测（对象字面量中有除指定目标类型外的属性时会报错）**
  > - **该对象字面量之后使用时，不再是新鲜的，不会被严格检测**





# 六. TS 枚举类型

---

## 01. TS 枚举类型

- 枚举类型是为数不多的 `TS` 特性有的特性之一：

  - 枚举其实**就是将 `一组可能出现的值`，一个个 `列举出来`，定义在一个类型中，这个类型就是 `枚举类型`**

  - 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型

    ```typescript
    enum Direction {
      TOP,
      BOTTOM,
      LEFT,
      RIGHT
    }
    
    const d1: Direction = Direction.LEFT
    
    function turnDirection(direction: Direction) {
      switch(direction) {
        case Direction.LEFT:
          console.log('转向左边')
          break
        case Direction.RIGHT:
          console.log('转向右边')
          break
        case Direction.TOP:
          console.log('转向上边')
          break
        case Direction.BOTTOM:
          console.log('转向下边')
          break
        default:
          const myDirection: never = direction
      }
    }
    ```

## 02. 枚举类型的值

- 枚举类型默认是有值的，比如上面的枚举，默认值是这样的：

  ```typescript
  enum Direction {
    TOP, // 默认值为0，依次递增
    BOTTOM, // 1
    LEFT, // 2
    RIGHT // 3
  }
  ```

- 当然，我们也可以给枚举其他值：

  - 这个时候会从`100`进行递增

    ```typescript
    enum Direction {
      TOP, // 100
      BOTTOM, // 101
      LEFT, // 102
      RIGHT // 103
    }
    ```

- **枚举类型 `默认值` 为 `0`，`默认类型` 为 `number`**

- 我们也可以给它们赋值其他的类型：

  - **赋值为 `其他类型` 时，所有的 `枚举成员` 都必须具有 `初始化值`**

    ```typescript
    enum Direction {
      TOP = 'left',
      BOTTOM = 'bottom', 
      LEFT = 'left',
      RIGHT // 报错：枚举成员必须具有初始化表达式
    }
    ```



