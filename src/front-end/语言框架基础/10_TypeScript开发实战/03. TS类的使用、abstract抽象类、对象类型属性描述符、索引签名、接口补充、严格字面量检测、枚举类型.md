# 一. TypeScript 中类的使用
> 在早期的 JavaScript（ES5）开发中，需要通过函数和原型链来实现类和继承，从 ES6 开始，引入了 class 关键字，可以更加方便的定义和使用类。   
> 在现代 JavaScript（JS）和 TypeScript（TS）中，类是面向对象编程（OOP）的核心概念。
> TS 作为 JS 的超集，可以对类的属性和方法等进行静态类型检测，为我们带来了更强大的类型检查能力。  
> 即使在一些更偏函数式编程的框架（如 React 的函数组件和 Vue3 的 Composition API）中，我们在封装复杂的业务逻辑时依然会频繁使用类来实现模块化、继承和多态。

## 类的定义
在 TypeScript 中，我们使用 class 关键字来定义类，在类的内部声明类的属性以及对应的类型。
::: warning
> - 如果类属性类型没有显式声明或属性没有初始化值，则类型默认 any。  
> - 在 tsconfig.json 配置文件中的 strictPropertyInitialization 开启的情况下，类属性**默认是必须初始化的**，如果**类属性没有初始化值且未在构造函数中明确赋值，那么编译时就会报错。**
> - 如果 strictPropertyInitialization 选项为 true，但确实不希望给类属性初始化，可以使用明确赋值断言：`property!: type` 语法，即在类属性后面加上 `!`，来绕过初始化检查。
:::
示例：
 ```typescript
 class Person {
   name: string;     // [!code error] // Error：属性“name”没有初始化表达式，且未在构造函数中明确赋值
   name2: any;       // 或改为 any 类型
   name3: number;    // 或改为在构造函数中有明确赋值
   name4!: boolean;  // 或改为使用明确赋值断言，跳过初始化检查（带有明确赋值断言的声明还必须具有类型注释）
   name5 = 1;        // 或改为初始化赋值，可省略类型注解，会根据初始值自动推导出类型 
   constructor(name: string, name3: number) {
     this.name3 = name3
   }
 }
  
const p1 = new Person('later', 18)
```

## 类的继承
> 面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。
在 TS 中可以使用 extends 关键字实现类的继承。子类继承父类的属性和方法，还可以有自己的属性和方法。通过 super 关键字，子类可以调用父类的构造函数和方法。

示例：定义一个 Student 类继承 Person 类
```typescript
class Person {
  name: string
  age: number
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
  greet() {
    console.log(`Hello, I am ${this.name}.`)
  }
}

class Student extends Person {
  studentId: number
  constructor(name: string, age: number, studentId: number) {
    super(name, age) // 调用父类的构造函数（必须写在构造函数体的第一行）
    this.studentId = studentId
  }
  sayHello() {
    super.greet()
  }
  study() {
    console.log(`${this.name} is studying.`)
  }
}

const student = new Student("Bob", 20, 12345)
student.sayHello() // 输出: Hello, I am Bob.
student.study()    // 输出: Bob is studying.
```
示例说明：
  > ① Student 类通过 extends 关键字继承了 Person 类。  
  > ② 在 Student 的构造函数中，super 关键字调用了 Person 的构造函数，完成父类属性的初始化。  
  > ③ eStudent 拥有自己特有的 study 方法。


## 类的成员修饰符
TypeScript 提供了 **public、private 和 protected 三种修饰符来控制类成员的可见性**：
::: tip
类成员指的是类中定义的属性，方法等，readonly 修饰符只能用于类属性，不能用于类方法，因此在本节内容不适用。
:::
  | 修饰符 | 含义 | 作用范围 |
  | - | - | - |
  | public（默认） | 公有 | 无限制 |
  | private | 私有 | 只能被类自身访问 |
  | protected | 受保护 | 只能被类自身及子类自身访问 |

示例：
  ```typescript
  // 示例一：protected 修饰的类成员，只能被类自身及子类自身访问
  class Person {
    protected name: string
    constructor(name: string) {
      this.name = name
    }
  }
  
  class Student extends Person {
    constructor(name: string) {
      super(name)
    }
    running() { 
      console.log(this.name) // protected 修饰的类成员，可以被子类自身访问
    }
  }
  
  const p1 = new Person('later')
  const s1 = new Student('later-zc')
  p1.name      // [!code error] // Error：属性“name”是受保护的，只能在类“Person”及其子类中访问
  s1.name      // [!code error] // Error：属性“name”是受保护的，只能在类“Person”及其子类中访问
  s1.running() // 输出: later-zc
  Person.name  // 输出: later-zc
  Student.name // 输出: later-zc


  // 示例二：private 修饰的类成员，只能被类自身访问
  class Person {
    private name: string
    constructor(name: string) {
      this.name = name
    }
  }
  
  const p2 = new Person('later')
  Person.name // 输出: later
  p2.name     // [!code error] // Error：属性“name”为私有属性，只能在类“Person”中访问
  ```


## readonly 修饰类属性为只读
::: warning
readonly 修饰符**只能出现在属性声明或索引签名上，不能用于类方法**。

readonly 是 TypeScript 关键字，它不会在 JavaScript 中生效，**只会在 TS 编译时限制对属性的修改**。
:::
使用 readonly 修饰符的属性只能在初始化或构造函数中赋值，赋值后不可修改。
  ```typescript
  class Person {
    readonly name: string
    constructor(name: string) {
      this.name = name
    }
    updateName(_name: string) {
      this.name = _name // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
    }
  }
  
  const p1 = new Person('later')
  console.log(p1.name)   // 可以访问
  p1.name = 'later-zc';  // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
  p1.updateName('coder') // [!code error] // Error：无法分配到 "name" ，因为它是只读属性
  ```
如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用。 那么可以使用 readonly。


## getters / setters
在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取 `getter` 和设置 `setter` 的过程，这个时候我们可以使用**存取器**。
  ```typescript
  class Person {
    private _name: string
    constructor(name: string) {
      this._name = name
    }
    get name() {
      return this._name
    }
    set name(value: string) {
      this._name = value
    }
  }
  
  const p1 = new Person('later')
  p1.name = 'later-zc' // 设置 name 属性
  console.log(p1.name) // 输出：later-zc
  ```
在这个示例中，我们通过 get 和 set 关键字控制对 _name 属性的访问，这样可以对赋值过程进行校验或修改。


## 参数属性（Parameter Properties）
参数属性是 TS 提供的一种简写方式，可以**在构造函数参数前直接添加修饰符**（如 public、private、protected 或 readonly）**将该构造函数参数转成一个同名同值的类属性**（同时这些类属性也会获得相应的修饰符）。
  ```typescript
  class Person {
    constructor(public name: string, private _age: number) {}
    set age(value: number) {
      this._age = value
    }
    get age() {
      return this._age
    }
  }
  
  const p1 = new Person('later', 18)
  console.log(p1.name) // 'later'
  console.log(p1._age) // [!code error] // Error： 属性‘_age’是私有的，只能在类‘Person’中访问。
  console.log(p1.age)  // 18
  ```
::: warning
> - 参数属性的访问修饰符 `publice` 不能省略，否则会报错。
> - 类成员的访问修饰符 `public` 可以省略，因为其默认就是 `public`。
:::



# 二. TypeScript 中的抽象类

## 什么是抽象类和抽象方法？
> 我们知道，继承是多态使用的前提，抽象类和抽象方法则是实现多态的有效方式。所以在定义很多通用的调用接口时，我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式，
但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法，我们可以定义为抽象方法。

**抽象方法**
> 指的是**用 abstract 关键字声明的方法。不能有方法体，只能存在于抽象类中，且必须在子类中被实现（除非子类也是抽象类）**。

**抽象类**
> 指的是**用 abstract 关键字声明的类，不能被实例化，只能被继承，抽象类可以包含抽象方法，也可以包含有实现体的方法**。
> 通常用来定义一组共有的属性和方法接口，具体的实现交由子类完成。

**为什么要使用抽象类？**
> - **实现多态**：可以在父类中定义通用接口（方法或属性），在子类中实现特定的功能。
> - **限制类的实例化**：抽象类只能作为基类存在，不能直接被实例化，避免了父类实例化带来的不必要问题。

例子：
```typescript
// 定义一个抽象类 Shape（图形类）
abstract class Shape {
  // 声明抽象方法 getArea，无方法体，非抽象类的子类必须实现它
  abstract getArea(): number
  // 非抽象方法：可以在抽象类中定义带有具体实现的方法
  showArea() {
    console.log("图形的面积是: " + this.getArea())
  }
}

// 定义具体的子类 Rectangle（矩形），继承 Shape
class Rectangle extends Shape {
  constructor(public width: number, public height: number) {
    super()
  }
  // 非抽象类的子类必须实现父类的抽象方法 getArea
  getArea() {
    return this.width * this.height
  }
}

// 定义另一个子类 Circle（圆形），继承 Shape
class Circle extends Shape {
  constructor(public radius: number) {
    super()
  }
  getArea(): number {
    return Math.pow(this.radius, 2) * Math.PI
  }
}

function printArea(shape: Shape) {
  return shape.showArea() 
}

printArea(new Rectangle(10, 20)) // 输出：图形的面积是: 200
printArea(new Circle(5))         // 输出：图形的面积是: 78.53981633974483
printArea(new Shape())           // [!code error] // Error：不能创建抽象类的实例
```
  

## 鸭子类型
> TypeScript 使用鸭子类型（Duck Typing）来进行类型检测，即**只检查对象的结构是否匹配，而不关心对象的实际类型**。也就是说，**只要对象具有对应的属性和方法，它就可以被视为符合某个类型**。

示例：
```typescript
class Person {
  constructor(public name: string, public age: number) {}
  run() {}
}

class Coder {
  constructor(public name: string, public age: number) {}
  run() {}
}

function printPerson(p: Person) {
  console.log(p.name, p.age)
}

// 下面三种情况都不会报错，就是因为 TypeScript 使用的鸭子类型来进行类型检测
// 鸭子类型: 如果一只鸟, 走起来像鸭子, 游起来像鸭子, 看起来像鸭子, 那么你可以认为它就是一只鸭子
// 鸭子类型, 只关心属性和行为, 不关心你具体是不是对应的类型
printPerson(new Coder('later', 20))
const p: Person = new Coder('later', 20)
printPerson({name: 'later', age: 20, run(){}}) // 甚至可以直接传递一个拥有相同属性的对象字面量

class Dog {}
const d: Dog = {} // 这也是符合鸭子类型的
```
在这个例子中，尽管 coder 类不是 Person 类的实例，但它的结构满足 Person 的要求，因此它可以被当作 Person 类型使用。这就是鸭子类型的思想。
不要求对象一定是由对应的类创建的实例，只要结构匹配即可。


## 类作为一种数据类型
在 TypeScript 中，类不仅可以用来创建实例，也可以作为数据类型。一个类的类型描述了该类的实例的结构，包括属性和方法。
  ```typescript
  class Person {}
  
  /**
    * 类的作用:
    *  1. 可以创建类对应的实例对象
    *  2. 类本身可以作为这个实例的类型
    *  3. 类也可以当作有一个构造签名的函数，因为类可以被 new
  */
  
  const p: Person = new Person() // 1
  function printPerson(p: Person) {}
  printPerson(p) // 2
  
  function factory(ctor: new () => void) {}
  factory(Person) // 3
  ```



# 三. TypeScript 对象类型
> 在 TypeScript 中，定义对象类型时，我们可以使用各种修饰符和类型特性来控制属性的可选性、只读性、索引特性等。这样不仅可以定义对象的基本结构，还能限制和规范对象的使用。

## 对象类型的属性修饰符（Property Modifiers）
对象类型中的每个属性可以说明它的类型、属性是否可选、属性是否只读等信息。

### 可选属性（Optional Properties）
> 在 TypeScript 中，我们可以通过**在属性名后加一个 ? 来标记该属性为可选**。这样可以定义对象类型时允许某些属性不出现。

  示例：
  ```typescript
  interface IPerson {
    name: string
    age?: number // 可选属性
  }
  
  const p1: IPerson = { name: "Alice" }        // 没有 age 属性
  const p2: IPerson = { name: "Bob", age: 30 } // 包含 age 属性
  ```

### 只读属性（Readonly Properties）
> 有时候我们希望对象中的某些属性在赋值后不可修改，这时可以在属性前加 readonly 关键字，将该属性设置为只读。这只会在编译时有效，防止该属性被意外修改。
  
  示例：
  ```typescript
  interface ICar {
    readonly brand: string
    model: string
  }
  
  const c1: ICar = { brand: "Toyota", model: "Corolla" }
  c1.model = "Camry"; // 可以修改 model
  c1.brand = "Honda"; // [!code error] // Error：因为 brand 是只读属性
  ```

## 索引签名（Index Signatures）

- 什么是索引签名呢？

  - 有时候，你不能提前知道一个类型里的所有属性的名字

  - 但是你知道这些值的特征

  - 这种情况，你就可以**用一个 `索引签名` 来描述 `可能的值` 的类型**
  
    ```typescript
    interface ICollection {
      // 返回值类型的目的是告知通过索引去获取到的值是什么类型
      [index: number]: string
      length: number 
    }
    
    function printCollection(collection: ICollection) {
      for (let i = 0; i < collection.length; i++) {
        const item = collection[i]
        console.log(item.length)
      }
    }
    
    const array = ["abc", "cba", "nba"]
    const tuple: [string, string] = ["why", "广州"]
    printCollection(array)
    printCollection(tuple)
    ```

## 03. 索引签名奇怪的现象

```typescript
interface IIndexType {
  [index: string]: string
}
const names: IIndexType = ["abc", "cba", "nba"] // 报错：不能将类型“string[]”分配给类型“IIndexType”。类型“string[]”中缺少类型“string”的索引签名


interface IIndexType2 {
  [index: number]: string
}
const names2: IIndexType2 = ["abc", "cba", "nba"] // 不报错

// 为什么会出现上面的情况？
// 因为我们字面量形式定义的数组，是会经过严格字面量赋值检测的，而数组本身还具有其他的一些属性，比如：forEach，filter这些属性
// 而这些属性其对应的值并不是string类型
// ["abc", "cba", "nba"] => Array实例 => names[0]、names.forEach、...
// names["forEach"] => function
// names["map/filter"] => function

// 既然有严格字面量检查，那我们让它不是新鲜的不就可以绕过检查了吗？
// 经过测试发现，可能索引签名这里是比较特殊的，即使使其失去新鲜，仍然会保持严格的字面量检查

// 所以当索引类型为string时，除了会检测['abc', 'cba', 'nba']中的['0']、['1']、['2']这几个字符串索引，
// 还会检测到['forEach']、['filter']这些字符串索引，而这些索引对应的值就并不符合string类型，所以就会报错，我们可以使用any类型来解决
// [index: string]: any

// 当索引类型为number时，只会检测['abc', 'cba', 'nba']中的[0]、[1]、[2]这几个数字索引，这几个索引所对应的值也是符合string类型的，所以不会报错
```

> 注意：
>
> - 当索引一个数字时，`JS` 实际上会在**索引对象**之前**将其转换**为字符串，即`[0] `等价于`['0']`

## 04. 两个索引签名

- 有时候我们可能会像下面这样来使用索引签名：

  ```typescript
  interface IIndexType {
    // 两个索引类型的写法
    [index: number]: string | number // 报错：“number”索引类型“string | number”不能分配给“string”索引类型“string”
    [key: string]: string
  }
  ```

- 会报如上的错，这是因为 `TS` 中指定了 `number` 索引类型返回的类型必须是 `string` 索引类型返回的类型中的子类型

- 所以改成如下即可：

  ```typescript
  interface IIndexType {
    [index: number]: string | number
    [key: string]: any // string返回的类型改成any，也或者将number返回的类型缩小成string所包含的类型
  }
  ```

> 注意：
>
> - 一个索引签名的属性类型必须是 `string` 或者是 `number`
> - 虽然 `TS` 可以同时支持 `string` 和 `number` 类型，但**数字索引**的**返回类型**一定要是**字符索引**的**返回类型**的**子类型**
> - 如果索引签名中有定义其他属性，**其他属性返回的类型，也必须符合`string`类型返回的属性**





# 四. TS 接口补充

---

## 01. 接口继承

- 接口和类一样是可以进行继承的，也是使用 `extends` 关键字：

  - 并且我们会发现，**接口是支持多继承的（类不支持多继承）**

    ```typescript
    interface IPerson {
      name: string
      age: number
    }
    
    interface IRun {
      running: () => void
    }
    
    // 可以从其他的接口中继承过来属性
    // 1.减少了相同代码的重复编写
    // 2.如果使用第三库, 给我们定义了一些属性
    //  > 自定义一个接口, 同时你希望自定义接口拥有第三方某一个类型中所有的属性
    //  > 可以使用继承来完成
    interface IKun extends IPerson, IRun {
      // name: string 
      // age: number
      slogan: string
    }
    
    // 报错：类型“{ slogan: string; }”缺少类型“IKun”中的以下属性: name, age, running
    const ikun: IKun = { 
      slogan: '你干嘛，哎哟'
    }
    ```

## 02. 接口的实现

- 接口定义后，也是可以被类实现的：
  - 如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入
  
  - 这就是面向接口开发
  
    ```typescript
    interface IKun {
      name: string
      slogan: string
      dance: () => void
    }
    
    interface IRun {
      running: () => void
    }
    
    const ikun: IKun = {
      name: 'later',
      slogan: '你干嘛',
      dance: function() {}
    }
    
    
    class Person implements IKun, IRun {
      constructor(public name: string, public slogan: string, public dance: () => void, public running: () => void) {}
    }
    
    const ikun1 = new Person('later', '小黑子', function(){}, function(){})
    console.log(ikun1.name, ikun1.slogan, ikun1.dance, ikun1.running)
    ```
  

## 3. 抽象类和接口的区别（了解）

- 抽象类在很大程度上和接口会有点类似：都可以在其中定义一个方法，让子类或实现类来实现对应的方法
- 那么抽象类和接口有什么区别呢？
  - 抽象类是事物的抽象，抽象类用来捕捉子类的通用特性，接口通常是一些行为的描述
  - 抽象类通常用于一系列关系紧密的类之间，接口只是用来描述一个类应该具有什么行为
  - 接口可以被多层实现，而抽象类只能单一继承
  - 抽象类中可以有实现体，接口中只能有对象的声明
- 通常我们会这样来描述类和抽象类、接口之间的关系：
  - **抽象类是对事物的抽象**，表达的是` is a `的关系。猫是一种动物（动物就可以定义成一个抽象类）
  - **接口是对行为的抽象**，表达的是` has a `的关系。猫拥有跑（可以定义一个单独的接口）、爬树（可以定义一个单独的接口）的行为





# 五. 特殊: 严格字面量检测

---

## 01. 严格的字面量赋值检测

- 对于对象的字面量赋值，在 `TS` 中有一个非常有意思的现象：

  ```typescript
  // 1.奇怪的现象一: 
  const info: IPerson = {
    name: "why",
    age: 18,
    // 多了一个height属性
    // 报错：不能将类型“{ name: string; age: number; height: number; }”分配给类型“IPerson”。对象文字可以只指定已知属性，并且“height”不在类型“IPerson”中
    height: 1.88 
  }
  
  const obj = {
    name: "why",
    age: 18,
    // 多了一个height属性
    height: 1.88
  }
  
  // 不报错
  const info2: IPerson = obj
  
  
  // 2.奇怪的现象二:
  function printPerson(person: IPerson) {}
  
  printPerson({ name: "kobe", age: 30, height: 1.98 }) // 报错：类型“{ name: string; age: number; height: number; }”的参数不能赋给类型“IPerson”的参数。对象文字可以只指定已知属性，并且“height”不在类型“IPerson”中
  
  const kobe = { name: "kobe", age: 30, height: 1.98 } 
  printPerson(kobe) // 不报错
  ```

## 02. 为什么会出现这种情况呢？

- 这里引入 `TS` 成员在 `GitHub` 的 `issue` 中的回答：

  <img src="./assets/image-20221017200449928.png" alt="image-20221017200449928" style="zoom: 67%;" />

- 简单对上面的英文进行翻译解释：

  - 每个对象字面量最初都被认为是“新鲜的（`fresh`）”
  - 当一个新的对象字面量分配给一个变量或传递给一个非空目标类型的参数时，对象字面量指定目标类型中不存在的属性是错误的
  - 当类型断言或对象字面量的类型扩大时（别的场景扩大使用时），新鲜度会消失
  
  > 总结：
  >
  > - **第一次创建的对象字面量，是新鲜的，会被严格检测（对象字面量中有除指定目标类型外的属性时会报错）**
  > - **该对象字面量之后使用时，不再是新鲜的，不会被严格检测**





# 六. TS 枚举类型

---

## 01. TS 枚举类型

- 枚举类型是为数不多的 `TS` 特性有的特性之一：

  - 枚举其实**就是将 `一组可能出现的值`，一个个 `列举出来`，定义在一个类型中，这个类型就是 `枚举类型`**

  - 枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型

    ```typescript
    enum Direction {
      TOP,
      BOTTOM,
      LEFT,
      RIGHT
    }
    
    const d1: Direction = Direction.LEFT
    
    function turnDirection(direction: Direction) {
      switch(direction) {
        case Direction.LEFT:
          console.log('转向左边')
          break
        case Direction.RIGHT:
          console.log('转向右边')
          break
        case Direction.TOP:
          console.log('转向上边')
          break
        case Direction.BOTTOM:
          console.log('转向下边')
          break
        default:
          const myDirection: never = direction
      }
    }
    ```

## 02. 枚举类型的值

- 枚举类型默认是有值的，比如上面的枚举，默认值是这样的：

  ```typescript
  enum Direction {
    TOP, // 默认值为0，依次递增
    BOTTOM, // 1
    LEFT, // 2
    RIGHT // 3
  }
  ```

- 当然，我们也可以给枚举其他值：

  - 这个时候会从`100`进行递增

    ```typescript
    enum Direction {
      TOP, // 100
      BOTTOM, // 101
      LEFT, // 102
      RIGHT // 103
    }
    ```

- **枚举类型 `默认值` 为 `0`，`默认类型` 为 `number`**

- 我们也可以给它们赋值其他的类型：

  - **赋值为 `其他类型` 时，所有的 `枚举成员` 都必须具有 `初始化值`**

    ```typescript
    enum Direction {
      TOP = 'left',
      BOTTOM = 'bottom', 
      LEFT = 'left',
      RIGHT // 报错：枚举成员必须具有初始化表达式
    }
    ```



